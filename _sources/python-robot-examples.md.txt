# Python ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡å®Ÿè·µä¾‹

## ã“ã®ç« ã§å­¦ã¶ã“ã¨

åŸºæœ¬çš„ãªPythonã®æ–‡æ³•ã‚’å­¦ã‚“ã ã‚ã¨ã¯ã€å®Ÿéš›ã®ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡ã«ç¹‹ãŒã‚‹å®Ÿè·µçš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã“ã®ç« ã§ã¯ã€ãƒ­ãƒœãƒƒãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ã€æ¥½ã—ã„ä¾‹é¡Œã‚’é€šã—ã¦å­¦ã³ã¾ã™ã€‚

## 1. åº§æ¨™ã¨ãƒ™ã‚¯ãƒˆãƒ«ã®åŸºç¤

### 1.1 2Dåº§æ¨™ã§ã®ä½ç½®è¡¨ç¾

```python
import math

class Point2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance_to(self, other):
        """2ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—"""
        dx = self.x - other.x
        dy = self.y - other.y
        return math.sqrt(dx * dx + dy * dy)
    
    def __str__(self):
        return f"({self.x}, {self.y})"

# ä½¿ç”¨ä¾‹
robot_pos = Point2D(0, 0)
target_pos = Point2D(3, 4)

distance = robot_pos.distance_to(target_pos)
print(f"ãƒ­ãƒœãƒƒãƒˆã‹ã‚‰ç›®æ¨™ã¾ã§ã®è·é›¢: {distance:.2f}cm")
```

### 1.2 3Dåº§æ¨™ã§ã®ä½ç½®è¡¨ç¾

```python
import math

class Point3D:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    
    def distance_to(self, other):
        """3æ¬¡å…ƒç©ºé–“ã§ã®è·é›¢è¨ˆç®—"""
        dx = self.x - other.x
        dy = self.y - other.y
        dz = self.z - other.z
        return math.sqrt(dx * dx + dy * dy + dz * dz)
    
    def __str__(self):
        return f"({self.x}, {self.y}, {self.z})"

# ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã®é–¢ç¯€ä½ç½®
shoulder = Point3D(0, 0, 50)
elbow = Point3D(30, 0, 80)
wrist = Point3D(50, 0, 70)

print(f"è‚©ã®ä½ç½®: {shoulder}")
print(f"è‚˜ã®ä½ç½®: {elbow}")
print(f"æ‰‹é¦–ã®ä½ç½®: {wrist}")
```

## 2. è¡Œåˆ—ã‚’ä½¿ã£ãŸå›è»¢è¨ˆç®—

### 2.1 2Då›è»¢è¡Œåˆ—

```python
import math

def rotate_point_2d(x, y, angle_degrees):
    """2æ¬¡å…ƒåº§æ¨™ã®å›è»¢"""
    angle_rad = math.radians(angle_degrees)
    cos_a = math.cos(angle_rad)
    sin_a = math.sin(angle_rad)
    
    # å›è»¢è¡Œåˆ—ã‚’é©ç”¨
    new_x = x * cos_a - y * sin_a
    new_y = x * sin_a + y * cos_a
    
    return new_x, new_y

# ä½¿ç”¨ä¾‹: ç‚¹(1, 0)ã‚’90åº¦å›è»¢
x, y = rotate_point_2d(1, 0, 90)
print(f"å›è»¢å¾Œã®åº§æ¨™: ({x:.2f}, {y:.2f})")
```

### 2.2 ãƒ­ãƒœãƒƒãƒˆã®å‘ãã‚’å¤‰ãˆã‚‹

```python
class Robot2D:
    def __init__(self, x, y, angle):
        self.x = x
        self.y = y
        self.angle = angle  # åº¦æ•°æ³•
    
    def turn(self, turn_angle):
        """ãƒ­ãƒœãƒƒãƒˆã®å‘ãã‚’å¤‰æ›´"""
        self.angle += turn_angle
        self.angle = self.angle % 360  # 0-359åº¦ã®ç¯„å›²ã«æ­£è¦åŒ–
    
    def move_forward(self, distance):
        """å‰é€²"""
        angle_rad = math.radians(self.angle)
        self.x += distance * math.cos(angle_rad)
        self.y += distance * math.sin(angle_rad)
    
    def get_front_position(self, distance):
        """å‰æ–¹ã®ä½ç½®ã‚’å–å¾—"""
        angle_rad = math.radians(self.angle)
        front_x = self.x + distance * math.cos(angle_rad)
        front_y = self.y + distance * math.sin(angle_rad)
        return front_x, front_y
    
    def status(self):
        return f"ä½ç½®: ({self.x:.2f}, {self.y:.2f}), å‘ã: {self.angle}Â°"

# ä½¿ç”¨ä¾‹
robot = Robot2D(0, 0, 0)
print(f"åˆæœŸçŠ¶æ…‹: {robot.status()}")

robot.turn(90)  # å·¦ã«90åº¦å›è»¢
print(f"å›è»¢å¾Œ: {robot.status()}")

robot.move_forward(10)  # 10cmå‰é€²
print(f"å‰é€²å¾Œ: {robot.status()}")
```

## 3. ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†

### 3.1 è·é›¢ã‚»ãƒ³ã‚µãƒ¼ã®ãƒ‡ãƒ¼ã‚¿å‡¦ç†

```python
import random

class DistanceSensor:
    def __init__(self, max_range=100):
        self.max_range = max_range
    
    def get_distance(self):
        """è·é›¢ã‚»ãƒ³ã‚µãƒ¼ã®å€¤ã‚’å–å¾—ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰"""
        # å®Ÿéš›ã®ãƒ­ãƒœãƒƒãƒˆã§ã¯ã€ã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰å®Ÿéš›ã®å€¤ã‚’å–å¾—
        return random.uniform(10, self.max_range)
    
    def is_obstacle_detected(self, threshold=30):
        """éšœå®³ç‰©æ¤œå‡º"""
        distance = self.get_distance()
        return distance < threshold, distance

# ä½¿ç”¨ä¾‹
sensor = DistanceSensor()

for i in range(5):
    is_obstacle, distance = sensor.is_obstacle_detected()
    if is_obstacle:
        print(f"è­¦å‘Š: éšœå®³ç‰©ã‚’æ¤œå‡ºï¼è·é›¢: {distance:.1f}cm")
    else:
        print(f"å®‰å…¨: è·é›¢: {distance:.1f}cm")
```

### 3.2 è¤‡æ•°ã‚»ãƒ³ã‚µãƒ¼ã®çµ±åˆ

```python
class MultiSensor:
    def __init__(self):
        self.front_sensor = DistanceSensor()
        self.left_sensor = DistanceSensor()
        self.right_sensor = DistanceSensor()
    
    def get_all_distances(self):
        """å…¨ã‚»ãƒ³ã‚µãƒ¼ã®å€¤ã‚’å–å¾—"""
        return {
            'front': self.front_sensor.get_distance(),
            'left': self.left_sensor.get_distance(),
            'right': self.right_sensor.get_distance()
        }
    
    def find_safest_direction(self):
        """æœ€ã‚‚å®‰å…¨ãªæ–¹å‘ã‚’åˆ¤å®š"""
        distances = self.get_all_distances()
        
        # æœ€ã‚‚é ã„éšœå®³ç‰©ãŒã‚ã‚‹æ–¹å‘ã‚’é¸æŠ
        safest_direction = max(distances, key=distances.get)
        return safest_direction, distances[safest_direction]

# ä½¿ç”¨ä¾‹
multi_sensor = MultiSensor()
direction, distance = multi_sensor.find_safest_direction()
print(f"æœ€ã‚‚å®‰å…¨ãªæ–¹å‘: {direction}, è·é›¢: {distance:.1f}cm")
```

## 4. çµŒè·¯è¨ˆç”»ã®åŸºç¤

### 4.1 ç›´ç·šçµŒè·¯ã®è¨ˆç®—

```python
def calculate_straight_path(start, goal, num_points=10):
    """ç›´ç·šçµŒè·¯ã‚’è¨ˆç®—"""
    path = []
    
    for i in range(num_points + 1):
        t = i / num_points
        x = start.x + (goal.x - start.x) * t
        y = start.y + (goal.y - start.y) * t
        path.append(Point2D(x, y))
    
    return path

# ä½¿ç”¨ä¾‹
start = Point2D(0, 0)
goal = Point2D(10, 5)

path = calculate_straight_path(start, goal)
print("çµŒè·¯:")
for i, point in enumerate(path):
    print(f"  {i}: {point}")
```

### 4.2 éšœå®³ç‰©å›é¿ã®ç°¡å˜ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

```python
class SimplePathPlanner:
    def __init__(self, robot):
        self.robot = robot
        self.sensor = MultiSensor()
    
    def plan_next_move(self, target_x, target_y):
        """æ¬¡ã®ç§»å‹•ã‚’è¨ˆç”»"""
        # ç›®æ¨™ã¸ã®æ–¹å‘ã‚’è¨ˆç®—
        dx = target_x - self.robot.x
        dy = target_y - self.robot.y
        target_angle = math.degrees(math.atan2(dy, dx))
        
        # ã‚»ãƒ³ã‚µãƒ¼ã§éšœå®³ç‰©ã‚’ãƒã‚§ãƒƒã‚¯
        distances = self.sensor.get_all_distances()
        
        if distances['front'] > 40:  # å‰æ–¹ãŒå®‰å…¨
            # ç›®æ¨™æ–¹å‘ã«å‘ã
            angle_diff = target_angle - self.robot.angle
            if angle_diff > 180:
                angle_diff -= 360
            elif angle_diff < -180:
                angle_diff += 360
            
            if abs(angle_diff) > 10:
                turn_angle = 10 if angle_diff > 0 else -10
                return 'turn', turn_angle
            else:
                return 'move', 20  # 20cmå‰é€²
        else:
            # éšœå®³ç‰©ãŒã‚ã‚‹ã®ã§å›é¿
            if distances['left'] > distances['right']:
                return 'turn', 45  # å·¦ã«45åº¦å›è»¢
            else:
                return 'turn', -45  # å³ã«45åº¦å›è»¢

# ä½¿ç”¨ä¾‹
robot = Robot2D(0, 0, 0)
planner = SimplePathPlanner(robot)

# ç›®æ¨™ä½ç½®(50, 30)ã«å‘ã‹ã†
target_x, target_y = 50, 30

for step in range(10):
    action, value = planner.plan_next_move(target_x, target_y)
    
    if action == 'turn':
        robot.turn(value)
        print(f"ã‚¹ãƒ†ãƒƒãƒ— {step+1}: {value}åº¦å›è»¢")
    elif action == 'move':
        robot.move_forward(value)
        print(f"ã‚¹ãƒ†ãƒƒãƒ— {step+1}: {value}cmå‰é€²")
    
    print(f"  ç¾åœ¨ä½ç½®: {robot.status()}")
    
    # ç›®æ¨™ã«åˆ°é”ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
    distance_to_goal = math.sqrt((target_x - robot.x)**2 + (target_y - robot.y)**2)
    if distance_to_goal < 5:
        print("ç›®æ¨™ã«åˆ°é”ã—ã¾ã—ãŸï¼")
        break
```

## 5. PIDåˆ¶å¾¡ã®åŸºç¤

### 5.1 PIDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å®Ÿè£…

```python
class PIDController:
    def __init__(self, kp, ki, kd):
        self.kp = kp  # æ¯”ä¾‹ã‚²ã‚¤ãƒ³
        self.ki = ki  # ç©åˆ†ã‚²ã‚¤ãƒ³
        self.kd = kd  # å¾®åˆ†ã‚²ã‚¤ãƒ³
        
        self.previous_error = 0
        self.integral = 0
    
    def calculate(self, error, dt):
        """PIDåˆ¶å¾¡ã®è¨ˆç®—"""
        # æ¯”ä¾‹é …
        proportional = self.kp * error
        
        # ç©åˆ†é …
        self.integral += error * dt
        integral_term = self.ki * self.integral
        
        # å¾®åˆ†é …
        derivative = (error - self.previous_error) / dt
        derivative_term = self.kd * derivative
        
        # å‡ºåŠ›
        output = proportional + integral_term + derivative_term
        
        self.previous_error = error
        return output

# ä½¿ç”¨ä¾‹: ãƒ­ãƒœãƒƒãƒˆã®ä½ç½®åˆ¶å¾¡
def simulate_position_control():
    # PIDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ä½œæˆ
    pid = PIDController(kp=1.0, ki=0.1, kd=0.05)
    
    target_position = 100  # ç›®æ¨™ä½ç½®
    current_position = 0   # ç¾åœ¨ä½ç½®
    dt = 0.1  # æ™‚é–“é–“éš”
    
    print("ä½ç½®åˆ¶å¾¡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³:")
    print("æ™‚é–“\tç¾åœ¨ä½ç½®\tèª¤å·®\tåˆ¶å¾¡å‡ºåŠ›")
    
    for t in range(50):
        time = t * dt
        
        # èª¤å·®ã‚’è¨ˆç®—
        error = target_position - current_position
        
        # PIDåˆ¶å¾¡ã®è¨ˆç®—
        control_output = pid.calculate(error, dt)
        
        # ãƒ­ãƒœãƒƒãƒˆã®ä½ç½®ã‚’æ›´æ–°ï¼ˆç°¡å˜ãªãƒ¢ãƒ‡ãƒ«ï¼‰
        current_position += control_output * dt
        
        if t % 10 == 0:  # 10ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«è¡¨ç¤º
            print(f"{time:.1f}\t{current_position:.2f}\t\t{error:.2f}\t{control_output:.2f}")
        
        # ç›®æ¨™ã«åˆ°é”ã—ãŸã‚‰çµ‚äº†
        if abs(error) < 0.1:
            print(f"ç›®æ¨™ã«åˆ°é”ã—ã¾ã—ãŸï¼ï¼ˆæ™‚é–“: {time:.1f}ç§’ï¼‰")
            break

simulate_position_control()
```

## 6. å®Ÿè·µãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼šæ¢ç´¢ãƒ­ãƒœãƒƒãƒˆ

ã“ã‚Œã¾ã§å­¦ã‚“ã æŠ€è¡“ã‚’çµ„ã¿åˆã‚ã›ã¦ã€è‡ªå¾‹çš„ã«å‹•ãæ¢ç´¢ãƒ­ãƒœãƒƒãƒˆã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```python
class ExplorationRobot:
    def __init__(self, x=0, y=0, angle=0):
        self.robot = Robot2D(x, y, angle)
        self.sensor = MultiSensor()
        self.visited_positions = []
        self.exploration_map = {}
    
    def explore_step(self):
        """1ã‚¹ãƒ†ãƒƒãƒ—ã®æ¢ç´¢"""
        # ç¾åœ¨ä½ç½®ã‚’è¨˜éŒ²
        current_pos = (round(self.robot.x), round(self.robot.y))
        self.visited_positions.append(current_pos)
        
        # ã‚»ãƒ³ã‚µãƒ¼ã§ã¾ã‚ã‚Šã‚’èª¿æŸ»
        distances = self.sensor.get_all_distances()
        self.exploration_map[current_pos] = distances.copy()
        
        # æ¬¡ã®è¡Œå‹•ã‚’æ±ºå®š
        if distances['front'] > 50:
            # å‰æ–¹ãŒå®‰å…¨ãªã‚‰å‰é€²
            self.robot.move_forward(30)
            return "å‰é€²"
        elif distances['left'] > distances['right']:
            # å·¦ã®æ–¹ãŒå®‰å…¨ãªã‚‰å·¦ã«å›è»¢
            self.robot.turn(90)
            return "å·¦å›è»¢"
        else:
            # å³ã«å›è»¢
            self.robot.turn(-90)
            return "å³å›è»¢"
    
    def get_exploration_summary(self):
        """æ¢ç´¢çµæœã®ã¾ã¨ã‚"""
        unique_positions = set(self.visited_positions)
        total_distance = len(self.visited_positions) * 30  # æ¦‚ç®—
        
        return {
            'visited_positions': len(unique_positions),
            'total_steps': len(self.visited_positions),
            'estimated_distance': total_distance,
            'current_position': (self.robot.x, self.robot.y),
            'current_angle': self.robot.angle
        }

# æ¢ç´¢ãƒ­ãƒœãƒƒãƒˆã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
def run_exploration_simulation():
    explorer = ExplorationRobot()
    
    print("=== æ¢ç´¢ãƒ­ãƒœãƒƒãƒˆ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ===")
    print("ãƒ­ãƒœãƒƒãƒˆãŒè‡ªå¾‹çš„ã«ç’°å¢ƒã‚’æ¢ç´¢ã—ã¾ã™\n")
    
    for step in range(20):
        action = explorer.explore_step()
        
        if step % 5 == 0:  # 5ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«çŠ¶æ³ã‚’å ±å‘Š
            summary = explorer.get_exploration_summary()
            print(f"ã‚¹ãƒ†ãƒƒãƒ— {step+1}: {action}")
            print(f"  ä½ç½®: ({summary['current_position'][0]:.1f}, {summary['current_position'][1]:.1f})")
            print(f"  å‘ã: {summary['current_angle']}Â°")
            print(f"  æ¢ç´¢æ¸ˆã¿ä½ç½®: {summary['visited_positions']}å€‹æ‰€")
            print()
    
    # æœ€çµ‚çµæœ
    final_summary = explorer.get_exploration_summary()
    print("=== æ¢ç´¢å®Œäº† ===")
    print(f"ç·ã‚¹ãƒ†ãƒƒãƒ—æ•°: {final_summary['total_steps']}")
    print(f"æ¢ç´¢æ¸ˆã¿ä½ç½®: {final_summary['visited_positions']}å€‹æ‰€")
    print(f"æ¨å®šç§»å‹•è·é›¢: {final_summary['estimated_distance']}cm")
    print(f"æœ€çµ‚ä½ç½®: ({final_summary['current_position'][0]:.1f}, {final_summary['current_position'][1]:.1f})")

# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
run_exploration_simulation()
```

## 7. ç·´ç¿’å•é¡Œ

### å•é¡Œ1: å††è»Œé“ã®è¨ˆç®—
ãƒ­ãƒœãƒƒãƒˆãŒåŠå¾„50cmã®å††ã‚’æãã‚ˆã†ãªè»Œé“ã‚’è¨ˆç®—ã—ã¦ãã ã•ã„ã€‚

```python
def calculate_circle_path(center_x, center_y, radius, num_points=36):
    """å††è»Œé“ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã‚’å®Œæˆã•ã›ã¦ãã ã•ã„"""
    path = []
    # ã“ã“ã«ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ãã ã•ã„
    return path

# ãƒ†ã‚¹ãƒˆ
circle_path = calculate_circle_path(0, 0, 50)
print(f"å††è»Œé“ã®ç‚¹æ•°: {len(circle_path)}")
```

### å•é¡Œ2: è¡çªæ¤œå‡º
2ã¤ã®ãƒ­ãƒœãƒƒãƒˆé–“ã®è¡çªã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°ã‚’ä½œã£ã¦ãã ã•ã„ã€‚

```python
def check_collision(robot1_pos, robot1_radius, robot2_pos, robot2_radius):
    """2ã¤ã®ãƒ­ãƒœãƒƒãƒˆã®è¡çªã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°ã‚’å®Œæˆã•ã›ã¦ãã ã•ã„"""
    # ã“ã“ã«ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ãã ã•ã„
    return False  # è¡çªãªã—ã®å ´åˆFalseã€è¡çªã‚ã‚Šã®å ´åˆTrue

# ãƒ†ã‚¹ãƒˆ
pos1 = Point2D(0, 0)
pos2 = Point2D(3, 4)
collision = check_collision(pos1, 2, pos2, 2)
print(f"è¡çª: {collision}")
```

## 8. ã¾ã¨ã‚

ã“ã®ç« ã§ã¯ã€ãƒ­ãƒœãƒƒãƒˆãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã‚ˆãä½¿ã‚ã‚Œã‚‹å®Ÿè·µçš„ãªæŠ€è¡“ã‚’å­¦ã³ã¾ã—ãŸï¼š

- **åº§æ¨™ç³»**: 2D/3Dç©ºé–“ã§ã®ãƒ­ãƒœãƒƒãƒˆã®ä½ç½®è¡¨ç¾
- **å›è»¢è¡Œåˆ—**: ãƒ­ãƒœãƒƒãƒˆã®å‘ãã‚„é–¢ç¯€ã®å›è»¢è¨ˆç®—
- **ã‚»ãƒ³ã‚µãƒ¼å‡¦ç†**: è·é›¢ã‚»ãƒ³ã‚µãƒ¼ãªã©ã®ãƒ‡ãƒ¼ã‚¿å‡¦ç†
- **çµŒè·¯è¨ˆç”»**: ç›®æ¨™ä½ç½®ã¸ã®ç§»å‹•è¨ˆç”»
- **PIDåˆ¶å¾¡**: ç²¾å¯†ãªä½ç½®åˆ¶å¾¡
- **è‡ªå¾‹æ¢ç´¢**: ã‚»ãƒ³ã‚µãƒ¼æƒ…å ±ã‚’ä½¿ã£ãŸè‡ªå¾‹çš„ãªè¡Œå‹•

ã“ã‚Œã‚‰ã®æŠ€è¡“ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šé«˜åº¦ãªãƒ­ãƒœãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚

## 9. æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

- [scikit-robotå…¥é–€](robot-control/index.md): å®Ÿéš›ã®ãƒ­ãƒœãƒƒãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ãŸåˆ¶å¾¡
- [ROSã¨é€£æº](ros-basics/index.md): Robot Operating Systemã¨ã®é€£æº

---

**ğŸ’¡ ãƒ’ãƒ³ãƒˆ**: å®Ÿéš›ã®ãƒ­ãƒœãƒƒãƒˆã§ã¯ã€ã“ã‚Œã‚‰ã®è¨ˆç®—ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚åŠ¹ç‡çš„ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’é¸ã¶ã“ã¨ãŒé‡è¦ã§ã™ï¼